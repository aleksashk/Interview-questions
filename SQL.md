## SQL

[1. Что такое SQL?](#1-Что-такое-sql)

[2. Что такое DML и DDL?](#2-Что-такое-dml-и-ddl)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).](#6-Опишите-как-вставить-удалить-обновить-данные-в-таблицу)

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений (join) таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-sql-курсор)

[12. Опишите шаги по созданию и использованию курсора.](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос (sub-query)?](#16-Что-такое-подзапрос-sub-query)

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view(Представление)?](#20-Что-такое-view)

[21. Что такое JDBC?](#21-Что-такое-jdbc)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегестрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-connection)

[25. Что такое Statement, PrepareStatement? В чем разница между ними?](#25-Что-такое-statement-preparestatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-resultset)

[27. В чем разница между методами execute, executeUpdate, executeQueury?](#27-В-чем-разница-между-методами-execute-executeupdate-executequeury)

[28. Можно ли использовать возвращаемое значение execute() для проверки, что что-то обновилось?](#28-Можно-ли-использовать-возвращаемое-значение-execute-для-проверки-что-что-то-обновилось)

[29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#29-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[30. Для чего используется конструкция try-with-resources?](#30-Для-чего-используется-конструкция-try-with-resources)

## 1. Что такое SQL?

**SQL** («язык структурированных запросов») - декларативный язык программирования, применяемый для создания, модификации
и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

Изначально SQL баз основным способом работы пользователя с базой данных и позволял выполнять следующий набор операций:
+ создание в базе данных новой таблицы;
+ добавление в таблицу новых записей;
+ изменение записей;
+ удаление записей;
+ выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
+ изменение структур таблиц;

Со временем SQL усложнился - обогатился новыми конструкциями, обеспечил возможность описания и управления новыми 
хранимыми объектами (например, индексы, представления, триггеры и хранимые процедуры) - и стал приобретать черты, 
свойственные языкам программирования.

При всех своих изменениях SQL остается самым распространенным лингвистическим средством для взаимодействия пригладного
программного обеспечения с базами данных.

[к оглавлению](#SQL)

## 2. Что такое DML и DDL?

DDL - Data Declaration Language, характеризует операции над структурой данных.

DML - Data Manipulation Language, представляет операции над самими данными.

[к оглавлению](#SQL)

## 3. Что такое первичный ключ?

**Первичный ключ (primary key)** - столбец таблицы, имеющий уникальное значение для каждой записи. Первичный ключ 
используется для однозначной идентификации записей.

+ **Первичный ключ не может содержать NULL**. Значение NULL не может быть уникальным, потому что в других записях этот 
  столбец тоже может содержать NULL.
  
+ **Значение первичного ключа должно задаваться при вставке записи**. При вставке в таблицу записи без указания значения
  первичного ключа возникает риск создания записи с первичиным ключом NULL и появления дубликатов, а это нарушает 
  требования первой нормальной формы.
  
+ **Первичный ключ должен быть компактным**. Первичный ключ должен содержать только ту информацию, которая обеспечивает
  его уникальность, и ничего более.
  
+ **Значения первичного ключа должны оставаться неизменными**. Если бы первичный ключ можно было изменять, то ему можно 
  было бы случайно присвоить уже используемое значение. Первичный ключ должен быть уникальным.
  
Таблица может иметь только один первичный ключ, который может состоять из одного или нескольких полей. Когда несколько
полей используются в качестве первичного ключа, их называют составным ключом.

[к оглавлению](#SQL)

## 4. Что такое внешний ключ?

**Внешний ключ (foreign key)** - столбец таблицы, в котором хранятся значения **первичного ключпа** другой таблицы.

+ Имя внешнего ключа может отличаться от имени первичного ключа, с которым он связывается.

+ Первичный ключ, используемый внешним ключом, также называется родительским ключом. Таблица, которой принадлежит 
  первичный ключ, называется родительской таблицей.

+ Внешний ключ может использоваться для установления соответствия между записями двух таблиц.

+ Внешний ключ может содержать значения NULL, хотя в первичном ключе они запрещены. 

+ Значения внешнего ключа не обязаны быть уникальными - более того, чаще они уникальными не являются.

[к оглавлению](#SQL)

## 5. Какие виды связей между таблицами существуют и как они организуются?

### 1) Типы связей: «один-к-одному»
В связях этого типа запись из табицы `A` может быть связана НЕ БОЛЕЕ ЧЕМ С ОДНОЙ записью в таблице `B`. 

Допустим, в таблице `A` хранится ваше имя, а в табилце `B` - информация о доходах и номера социального страхования 
(такая **изоляция** повышает безопасность данных). 

Обычно данные, связанные по типу "один-к-одному", разумнее хранить в основной таблице, однако выделение их в отдельную
таблицу иногда приносит некоторые преимущества.

1. Выделение данных может ускорить обработку запросов. Например, если подавляющее большинство запросов извлекает только 
   номер социального страхования и ничего более, лучше обращаться с запросом к меньшей таблице.
   
2. Если столбец может содержать неизвестные на данный момент значения, выделение его в отдельную таблицу позовлит 
   избежать харнения NULL в основной таблице.
   
3. Изоляция части данных помогает ограничить доступ к ним. Например, если у вас имеется таблица с записями работников, 
   информцию о доходах лучше харнить отдельно от основной таблицы.
   
4. Большие блоки данных тоже лучше хранить в отдельной таблице.

### 2) Типы связей: «один-ко-многим»
В связях типа "один-ко-многим" запись в таблице `A` может быть связана со МНОГИМИ записями в таблице `B`, но каждая
запись в таблице `B` может быть связана только с ОДНОЙ записью в таблице `A`.

Допустим, каждая запись таблицы `professions` может быть связана со многими записями `employees`, но каждая запись
`employees` всегда связана только с одной записью в таблице `professions`.

### 3) Типы связей: «многие-ко-многим»
"Многие-ко-многим": в соединительной таблице хранятся ключи из обеих таблиц. Обычно они состоят из **двух связей 
"один-ко-многим"**, объединенных при помощи **соединительной таблицы**.

Допустим, **ОДИН** человек из таблицы `contacts` связывается со **МНОГИМИ** увлечениями из новой таблицы `interests`. 
Но так как каждое увлечение может принадлежать нескольким людям, такая связь относится к типу **многие-ко-многим**.

[к оглавлению](#SQL)

## 6. Опишите как вставить, удалить, обновить данные в(из) таблицу(ы).

###1) Вставка

Для вставки новых записей используется оператор `INSERT INTO`. Написать `INSERT INTO` можно двумя способами:

1. Укажите имена столбцов и значения для вставки:
```postgres-sql
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);
```
2. Если вы добавляете значения для всех столбцов таблицы, то не нужно указывать имена столбцов в запросе SQL. Однако 
   необходимо убедиться, что порядок значений соответствует порядку столбцов в таблице.
```postgres-sql
INSERT INTO table_name
VALUES (value1, value2, value3);
```

Также можно вставить данные в таблицу из выборки. Оператор `INSERT INTO SELECT` требует, чтобы типы данных в исходной и 
целевой таблицах совпадали. Существующие записи в целевой таблице затронуты не будут.

1. Скопирует записи со всеми столбцами из одной таблицы в другую. 
```postgres-sql
INSERT INTO table2
SELECT * FROM table1
WHERE condition;
```

2. Скопирует записи только некоторых столбцов из одной таблицы в другую.
```postgres-sql
INSERT INTO table2 (column1, column2, column3)
SELECT column1, column2, column3
FROM table1
WHERE condition;
```

###2) Удаление

Для удаления записей используется оператор `DELETE`
```postgres-sql
DELETE FROM table_name WHERE condition;
```

Можно удалить все строки в таблице, не удаляя таблицу:
```postgres-sql
DELETE FROM table_name;
```

###3) Обновление

Оператор `UPDATE` используется для изменения существующих записей в таблице.
```postgres-sql
UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;
```

[к оглавлению](#SQL)

## 7. Что такое нормализация БД?

**Нормализация** - это метод проектирования базы данных, который позволяет привести базу данных к минимальной
избыточности.

Избыточность устраняется, как правило, за счет декомпозиции отношений (таблиц), т.е. разбиения одной таблицы на 
несколько.

### Зачем нормализовать базу данных?

Избыточность данных создает предпосылки для появления различных аномалий, снижает производительность, и делает упраление
данными не гибким и не очень удобным. Нормализация нужна для:

+ Устранения аномалий
+ Повышения производительности
+ Повышения удобства управления данными

**Избыточность данных** - это когда одни и те же данные хранятся в базе в нескольких местах, именно это и приводит к 
аномалиям.

В целом процесс нормализации базы данных выглядит следующим образом: следуя определённым правилам и соблюдая 
определенные требования мы приводим базу данных к определенной нормальной форме.

**Нормальная форма базы данных** - это набор правил и критериев, которым должна отвечать база данных.

Каждая следующая нормальная форма содержит более строгие правила и критерии, тем самым приводя базу данных к 
определенной нормальной форме мы устраняем определенный набор аномалий.

База данных считается нормализованной, если она находится как минимум в третьей нормальной форме.

[к оглавлению](#SQL)

## 8. Что такое денормализация БД? Для чего она нужна?

Обычно под **денормализацией** понимают стратегию, применимую к уже нормализованной базе данных с целью повышения её 
производительности. Смысл этого действия - поместить избыточные данные туда, где они смогут принести максимальную 
пользу. Для этого можно использовать дополнительные поля в уже существующих таблицах, добавлять новые таблицы или даже
создавать новые экземпляры существующих таблиц. Логика в том, чтобы снизить время исполнения определенных запросов через
упрощение доступа к данным или через создание таблиц с результатами отчетов, построенных на основании исходных данных.

Непременной условие процесса денормализации - наличие нормализованной базы.

### Когда полезно использовать денормализацию

1. **Сохранение исторических данных.** Например, могут измениться имя и фамилия клиента или другие данные о его месте 
   жительства и роде занятий.
2. **Повышение производительности запросов.** Пример - ситуация, когда необходимо объединить до 10 таблиц для получения 
   имени клиента и наименования товаров, которые были ему проданы.
3. **Ускорение создания отчетов.** Например, требуется отслеживать клиентские продажи за определенный промежуток по 
   заданной группе или по всем пользователям разом. Решающий эту задачу запрос в "боевой" базе перелопатит её полностью,
   прежде чем подобный отчет будет сформирован.
4. **Предварительные вычисления часто запрашиваемых значений.** Всегда есть потребность держать наиболее часто 
   запрашиваемые значения наготове для регулярных расчетов, а не создавать их заново, генерируя их каждый раз в реальном
   времени.
   
### У денормализации есть своя цена

+ **Место на диске.** Данные дублируются.
+ **Аномалии данных.** Необходимо понимать, что с определенного момента данные могут быть изменены в нескольких местах 
  одновременно. Соответственно, нужно корректно менять их копии.
+ **Документация**. Каждое применение денормализации следует подробно документировать. 
+ **Замедление других операций**. Вполне возможно, что применение денормализации замедлит процессы вставки, модификации 
  и удаления данных.
+ **Больше кода**. Пункты 2 и 3 потребуют добавления кода.

[к оглавлению](#SQL)

## 9. Что такое кластерный и некластерный индексы?

По способу хранения данных отличают кластерные и обычные индексы.
+ **Обычный индекс** — это отсортированный набор данных колонки, по которой он построен. Индекс будет хранить ссылки
  на данные каждой строки для каждого значения `ID`.
+ **Кластерный индекс** (или кластерный ключ) сохраняет не только значения колонки в отсортированном виде,
  а и данные всей строки. Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом.
  В таблице может быть только один кластерный индекс. Кластерный индекс - это древовидная структура данных, при которой
  значения индекса хранятся вместе с данными, им соответствующими.

На движке InnoDB каждая таблица имеет кластерный ключ. Выбираются они по такому принципу:

+ Если в таблице задан `PRIMARY KEY` - это он;
+ Иначе, если в таблице есть `UNIQUE` индексы - это первый из них
+ Иначе InnoDB самостоятельно создаёт скрытое поле с суррогатным ID размером в 6 байт

https://habr.com/ru/post/141767/

типы индексов в PostgreSQL
https://postgrespro.ru/docs/postgresql/9.5/indexes-types

[к оглавлению](#SQL)

## 10. Какие типы соединений (join) таблиц существуют? В чем их разница?

+ **Перекрестное соединение** `CROSS JOIN` возвращает комбинации каждой записи первой таблицы с каждой записью второй 
   таблицы. Перекрастное соединение является разновидностью внутреннего соединения. В сущности, внутреннее соединение -
   это перекрестное соединение, из результатов которого некоторые записи исключены по критерию запроса.
   
+ **Внутренним соединением** `INNER JOIN` называется перекрестное соединение, из результатов которого часть записей 
   исключается по условию запроса. Внутреннее соединение комбинирует записи из двух таблиц в соответствии с заданным 
   условием.
   1. **Эквивалентное соединение** - внутреннее соединение с проверкой равенства.
   2. **Неэквивалентное соединение** возвращает записи, у которых заданные значения столбцов не равны.
   
+ **Естественные соединения** `NATURAL JOIN` возможны только в том случае, если столбец, по которому выполняется 
   соединение, имеет одинаковые имена в обеих таблицах.
   
+ **Левое внешнее соединение** `LEFT OUTER JOIN` перебирает все записи левой таблицы и ищет для каждой соответствие среди
   записей правой таблицы. Значение NULL в результатах левого внешнего соединения означает, что правая таблица не 
   содержит значений, соответствующих левой таблице.
   
+ **Правое внешнеее соединение** `RIGHT OUTER JOIN` почти полностью аналогично левому внешнему соединению, кроме того, 
   что оно сравнивает правую таблицу с левой. Правое внешнее соединение ищет в левой таблице соответствия для правой 
   таблицы.
   
+ **Полное соединение** `FULL JOIN`. Данный тип внешнего соединения дает разультат левого + правого соединений, т.е. 
   представляет собой комбинацию этих двух соединений. Работает он так: выполняется левое соединение, выполняется правое
   соединение и оба результата этих запросов попадают в результрующую выборку.
   
+ **Самосоединение** `SELF JOIN`. соединение таблицы с этой же таблицей.

[к оглавлению](#SQL)

## 11. Что такое SQL курсор?

Команды манипулирования данными `SELECT`, `UPDATE`, `DELETE` работают сразу с группами строк.
Эти группы, вплоть до отдельных строк, можно выбрать с помощью опции `WHERE`.
А если надо перебрать строки некоторой таблицы последовательно, одну за другой? На этот случай в языке SQL существуют курсоры.

**Курсор (current set of record)** – временный набор строк, которые можно перебирать последовательно, с первой до последней.
Это эффективный способ получать большие наборы строк из функций по частям.

С помощью курсоров можно выполнять следующие задачи:

+ Укажите положение в конкретных строках результирующего набора.
+ Получение одной строки или блока строк на основе текущего расположения результирующего набора.
+ Изменение данных в строках в текущей позиции результирующего набора.
+ Определите различные уровни чувствительности к изменениям данных, внесенным другими пользователями.

[Курсоры в PL/pgSQL](https://postgrespro.ru/docs/postgresql/9.5/plpgsql-cursors)

Ещё разное:

[Что такое курсор?](https://docs.microsoft.com/ru-ru/sql/ado/guide/data/what-is-a-cursor?view=sql-server-2017)

[Основы T-SQL и примеры — функции (UDF), триггеры, процедуры, курсоры, циклы](https://ivan-shamaev.ru/t-sql-fundamentals-and-examples/#i-6)

[Курсоры в MSSQL - перебор выборки в цикле.](https://kbss.ru/blog/mssql/55.html)

[к оглавлению](#SQL)

## 12. Опишите шаги по созданию и использованию курсора.

При работе с курсорами используются следующие команды.

+ **Объявление курсора**:
  `DECLARE имя_курсора CURSOR FOR SELECT текст_запроса`
  Любой курсор создается на основе некоторого оператора `SELECT`.

+ **Открытие курсора**:
  `OPEN имя_курсора`
  Для того чтобы с помощью курсора можно было читать строки, его надо обязательно открыть.

+ **Чтение следующей строки из курсора**:
  `FETCH имя_курсора INTO список_переменных`
  Переменные в списке должны быть в том же количестве и того же типа, что и столбцы курсора.
  Глобальная переменная `@@FETCH_STATUS` принимает ненулевое значение, если строк в курсоре больше нет.
  Если же набор строк еще не исчерпан, то `@@FETCH_STATUS` равна нулю, и оператор `FETCH` перепишет значения полей
  из текущей строки в переменные.

+ **Закрытие курсора**:
  `CLOSE имя_курсора`

+ Для **удаления курсора из памяти** используется команда
  `DEALLOCATE имя_курсора`

Для иллюстрации использования курсора создадим процедуру, которая будет выбирать данные из одной таблицы,
перебирать их в курсоре анализируя, есть ли такие данные во второй таблице и вставлять в третью таблицу,
если данные записи удовлетворяют определённым критериям.
```sql
CREATE PROCEDURE [dbo].[MyProcedure] AS
DECLARE @ID INT
DECLARE @QUA INT
DECLARE @VAL VARCHAR (500)
DECLARE @NAM VARCHAR (500)
/*Объявляем курсор*/
DECLARE @CURSOR CURSOR
/*Заполняем курсор*/
SET @CURSOR  = CURSOR SCROLL
FOR
SELECT INDEX, QUANTITY, VALUE, NAME  
  FROM My_First_Table WHERE  QUANTITY > 1
/*Открываем курсор*/
OPEN @CURSOR
/*Выбираем первую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
/*Выполняем в цикле перебор строк*/
WHILE @@FETCH_STATUS = 0
BEGIN
        IF NOT EXISTS(SELECT VAL FROM My_Second_Table WHERE ID=@ID)
        BEGIN
/*Вставляем параметры в третью таблицу если условие соблюдается*/
                INSERT INTO My_Third_Table (VALUE, NAME) VALUE(@VAL, @NAM)
        END
/*Выбираем следующую строку*/
FETCH NEXT FROM @CURSOR INTO @ID, @QUA, @VAL, @NAM
END
CLOSE @CURSOR
```

Также пример на Pl/PgSQL. Перебор таблицы и вывод данных о ней в консоль:
```postgres-sql
DO
$$
DECLARE l_name VARCHAR;
DECLARE curs CURSOR FOR SELECT name FROM cars;
BEGIN
	FOR l_name IN curs LOOP
		RAISE NOTICE '%', l_name;
	END LOOP;
END
$$ language plpgsql;
```

[к оглавлению](#SQL)

## 13. Что такое транзакция?

**Транзакция** представляет собой набор команд SQL, выполняемых как единое целое. 

Если в ходе транзакции не удается выполнить хотя бы одну операцию, то не выполняется ни одна операция.

**Свойства транзакций:**

Чтобы набор команд SQL мог считаться транзакцией, он должен обладать четырьмя свойствами: атомарностью, целостностью,
изолированностью и устойчивостью. В английском языке этот набор свойств часто обозначается сокращением ACID (Atomic,
Consistency, Isolation, Durability).

+ **Атомарность**. Завершаются либо все операции, входящие в транзакцию, либо не завершается ни одна. Транзакция не 
  может быть выполнена частично.
  
+ **Целостность**. Завершенная транзакция оставляет базу данных в логически целостном состоянии.

+ **Изолированность**. Каждая транзакция работает со своими целостным представлением базы данных независимо от других 
  транзакций, выполняемых одновременно с ней.
  
+ **Устойчивость**. После завершения транзакции база данных должна сохранить измененные данные, защитив их от сбоев 
  питания или других опасностей.
  
При работе с транзакциями в SQL используются три команды.

1. `START TRANSACTION` отслеживает выполнение всех последующих команд SQL вплость до выполнения `COMMIT` или `ROLLBACK`.
2. `COMMIT` если все команды выполнены успешно и все выглядит хорошо, закрепите изменения командой `COMMIT`.
3. `ROLLBACK` если что-то пошло не так, команда `ROLLBACK` отменяет все изменения, и база данных возвращается к 
   состоянию до ввода команды `START TRANSACTION`.

[к оглавлению](#SQL)

## 14. Что такое триггер? Какие типы триггеров Вы знаете?

**Триггер** является указанием, что база данных должна автоматически выполнить заданную функцию, всякий раз когда выполнен
определённый тип операции. Триггеры можно использовать с таблицами, с представлениями и с внешними таблицами.

[Обзор механизма работы триггеров в PostgreSQL](https://postgrespro.ru/docs/postgresql/9.5/trigger-definition)

[Обзор механизма работы триггеров событий в PostgreSQL](https://postgrespro.ru/docs/postgresql/9.5/event-trigger-definition)

**Триггеры** — это части кода, запускаемые автоматически и основанные на каком-либо действии или событии в таблице
базы данных.

Триггеры могут применять в таблице во время выполнения операторов `INSERT`, `UPDATE` или `DELETE`, а затем работать
или перед, или после этих действий.

Некоторые СУБД также позволяют работать триггерам на уровне оператора или на уровне каждой строки данных во
время ее изменения.

[Пример использования триггеров](https://habr.com/ru/post/146717/)

[к оглавлению](#SQL)

## 15. В чем разница между where и having?

`WHERE` - это условие, которое уточняет критерий отбора записей. Условие сужает результаты поиска, а команда возвращает 
только те записи, для которых это условие выполняется.

У метода `WHERE` есть одно ограничение - его нельзя использовать с агрегатными функциями. Для этих целей специально 
служит оператор `HAVING`. Применяет он аналогично `WHERE`, только в нем обязательно должна быть агрегатная функция.

[к оглавлению](#SQL)

## 16. Что такое подзапрос (sub-query)?

Подзапрос представляет собой запрос, "упакованный" в другом запросе. Также он может называться "внутренним запросом".

Подзапрос - не что иное, как запрос внутри другого запроса. "Охватывающий" запрос называется внешним, а "вложенный" - 
внутренним запросом, или подзапросом.

Подзапрос, используемый в качестве выражения столбца в команде SELECT, может возвращать только одно значение из одного 
столбца.

[к оглавлению](#SQL)

## 17. Что такое union?

`UNION` - это так называемые союзы. Союз объеденяет в одну таблицу разультаты двух и более запросов на основании того, 
что указано в запросе `SELECT`. Союзы можно трактовать как "пересекающиеся" значения всех запросов. 

Ограничения союзов:
+ Количество столбцов в командах `SELECT` должно быть одинаковым. Нельзя выбрать два столбца одной командой и ещё один 
  столбец другой.
  
+ Команды `SELECT` должны содержать одинаковые выражения и агрегатные функции.

+ Команды `SELECT` могут следовать в любом порядке; на результаты это не влияет.

+ По умолчанию SQL исключает дубликаты из результатов союзов.

+ Типы данных в столбцах должны совпадать, либо быть совместимыми.

+ Если по какой-то причине необходимо получить список со всеми дубликатами, используйте оператор `UNION ALL`. Он 
  возвращает все совпадения, не только уникальные.

[к оглавлению](#SQL)

## 18. Что такое group by?

Команда `GROUP BY` группирует все записи с полями, описанные после данной команды. Полезно, при использовании агрегатных
функций. Допустим, можно просуммировать одно поле, а другое сгруппировать (свернуть), и таким образом в выборке мы 
получим сумму для свернутого поля.

[к оглавлению](#SQL)

## 19. Что такое хранимые процедуры?

Объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере.
Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные
параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными,
результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные
операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления,
то есть в них могут использоваться инструкции управления процессом исполнения.
Хранимые процедуры похожи на определяемые пользователем функции (UDF). Основное различие заключается в том,
что пользовательские функции можно использовать как и любое другое выражение в SQL запросе, в то время как
хранимые процедуры должны быть вызваны с помощью функции `CALL`:

```sql
CALL процедура(…)
```
или

```sql
EXECUTE процедура(…)
```

Хранимые процедуры могут возвращать множества результатов, то есть результаты запроса `SELECT`.
Такие множества результатов могут обрабатываться, используя курсоры, другими сохранёнными процедурами,
возвращая указатель результирующего множества, либо же приложениями. Хранимые процедуры могут также содержать
объявленные переменные для обработки данных и курсоров, которые позволяют организовать цикл по нескольким
строкам в таблице. Стандарт SQL предоставляет для работы выражения `IF`, `LOOP`, `REPEAT`, `CASE` и многие другие.
Хранимые процедуры могут принимать переменные, возвращать результаты или изменять переменные и возвращать их,
в зависимости от того, где переменная объявлена.

[к оглавлению](#SQL)

## 20. Что такое view(Представление)?

В сущности, представление - это таблица, существующая только во время использования представления в запросе. 
Представление называется **виртуальной таблицей**, потому что ведет себя как настоящая таблица и с ним можно выполнять
те же операции, что и с  обычными таблицами. Виртуальная таблица не хранится в базе данных. Она создается тогда, когда
вы используете представление, а затем уничтожается.

**Почему представления удобны при работе с базами данных:**
1. Возможные изменения структуры базы данных не нарушат работы приложений, зависящих от таблиц.
2. Представления упрощают сложные запросы до простых команд.
3. Представления могут скрывать информацию, которая не нужна пользователю.

Если в представлении используются агрегатные функции, оно не может использоваться для обновления данных. Кроме того, 
если представление содержит условия `GROUP BY`, `DISTINCT`, или `HAVING`, изменение данных также невозможно.

[к оглавлению](#SQL)

## 21. Что такое JDBC?

JDBC – это API, т.е. набор вспомогательных классов, которое позволяет работать с базами данных. Причем JDBC 
предоставляет единый интерфейс для работы с ними, ведь бывают различные базы данных.

[к оглавлению](#SQL)

## 22. Что нужно для работы с той или иной БД?

Для работы с той или иной базой данных существует понятие драйвера. Драйвер – это то, что позволяет работать с бд 
(поддерживать подключения, выполнять запросы и т.д.). Для каждой БД есть свой драйвер.

[к оглавлению](#SQL)

## 23. Как зарегистрировать драйвер?

Чтобы добавить драйвер в проект необходимо добавить зависимость на этот самый драйвер.

Добавьте зависимость в проект:
```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.16</version>
</dependency>
```

После добавления зависимости на драйвер, нам необходимо его зарегистрировать в системе. Чтобы это сделать необходимо 
прописать строку:

```java
Class.forName("org.postgresql.Driver");
```

[к оглавлению](#SQL)

## 24. Как получить Connection?

Для подключения нам нужны url, логин (имя пользователя) и пароль. Чтобы получить подключение нужно воспользоваться 
классом `DriverManager`, передав ему эти аргументы.

```java
String url = "jdbc:postgresql://localhost:5432/idea_db";
String login = "postgres";
String password = "password";
try (Connection connection = DriverManager.getConnection(url, login, password)) {
```

Если объект типа `Connection` не равен `null`, то это значит, что установлено подключение и теперь можно выполнять 
запросы к базе данных.

[к оглавлению](#SQL)

## 25. Что такое Statement, PrepareStatement? В чем разница между ними?

Для исполнения операций существуют специальные классы: `Statement`, `PrepareStatement`. 

### Statement

`Statement` используется для выполнения SQL запросов к базе данных.
Объект `Statement` можно получить с помощью метода `Connection.getStatement()`.
Вызывая методы `execute()`, `executeQuery()`, `executeUpdate()` и др., можно выполнять различные статичные SQL запросы.

В случае динамически созданных SQL запросов внутри java программы, когда введенные пользователем данные могут быть
не проверенными, можно использовать `SQL injection`.

По умолчанию только один объект `ResultSet` для каждого `Statement` может быть открыт в одно и то же время.
Таким образом, если необходимо работать с несколькими объектами `ResultSet` одновременно, мы должны использовать 
различные объекты `Statement`. Все `execute()` методы в интерфейсе `Statement` закроют текущий открытый объект 
ResultSet` при выполнении.

### PrepareStatement

`PrepareStatement` используется для выполнения прекомпилированных SQL-запросов с или без входных (`IN`) параметров.
Мы можем использовать сеттеры для установки значений в запрос. Т.к. `PreparedStatement` является предкомпилированным,
то он может быть эффективно использован множество раз.

`PreparedStatement` считается лучшим выбором нежели `Statement`,
т.к. он автоматически обрабатывает специальные символы, а так же предотвращает, так называемые, `SQL injection attack`
(когда в запрос можно подставить свой код).

### Преимущества в использовании PreparedStatement над Statement:

+ `PreparedStatement` позволяет предотвратить атаки типа `SQL injection`, т.к. он автоматически экранирует специальные символы.

+ `PreparedStatement` позволяет использовать динамические запросы с внедрением параметров.

+ `PreparedStatement` быстрее `Statement`. Это особенно заметно при частом использовании `PreparedStatement `
  или при использовании для вызова группы запросов.

+ `PreparedStatement` позволяет писать объектно ориентированный код с использованием сеттеров\геттеров.
  А при применении `Statement` необходимо использовать конкатенацию строк для создания запроса.
  Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.


[к оглавлению](#SQL)

## 26. Что такое ResultSet?

`ResultSet` - интерфейс, объект которого создается в результате запроса к базе данных.
Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.

Объект `ResultSet` поддерживает курсор, который указывает на текущую строку данных.
При инициализации курсор устанавливается до первой строки. Для движения по строкам используется метод `next()`.
При наличии строк после текущей позиции, метод `next()` возвращает `true`, что можно использовать для итерации по таблице
полученных результатов.

По умолчанию объект `ResultSet` НЕмодифицируемый и поддерживает курсор, который способен только к движение вперед.
Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного
движения по таблице, а так же возможности обновления:

```sql
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                   ResultSet.CONCUR_UPDATABLE);
```

Объект `ResultSet` автоматически закрывается при закрытии объекта, который его сгенерировал.
Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.
Для использования геттера `ResultSet` можно использовать имя колонки или индекс, который начинается с `1`.

При создании `Statement` можно задать различные типы получаемого `ResultSet`.

Три типа объектов `ResultSet`:

1. **ResultSet.TYPE_FORWARD_ONLY:** тип по умолчанию. Поддерживает движение курсора только в прямом направлении.
2. **ResultSet.TYPE_SCROLL_INSENSITIVE:** Двунаправленный курсор. Объект не чувствителен к изменениям,
   которые произошли с таблицей после получения результата.
3. **ResultSet.TYPE_SCROLL_SENSITIVE:** Двунаправленный курсор. Объект чувствителен к изменениям, которые
   произошли с базой данных после создания объекта `ResultSet`.

Два типа потокобезопасных объектов `ResultSet`:

+ **ResultSet.CONCUR_READ_ONLY:** Поддерживает только чтение (read only). Применяется по умолчанию.
+ **ResultSet.CONCUR_UPDATABLE:** Поддерживает метод `ResultSet update` для обновления строк в таблице данных.

[к оглавлению](#SQL)

## 27. В чем разница между методами execute, executeUpdate, executeQueury?

Существует несколько способов выполнять SQL-запросы в зависимости от типа этого запроса.
Для этого у интерфейса `Statement` существует три различных метода: `executeQuery()`, `executeUpdate()`, а так же `execute()`.
Рассмотрим их отдельно:

+ Самый базовый метод `executeQuery()` необходим для запросов, результатом которых является один единственный набор значений,
  таких как у запросов `SELECT`. Возвращает `ResultSet`, который не может быть `null` даже если у результата запроса
  не было найдено значений.

+ Метод `execute()` используется, когда операторы SQL возвращают более одного набора данных, более одного счетчика обновлений
  или и то, и другое. Метод возвращает `true`, если результатом является `ResultSet`, как у запроса `SELECT`. Вернет `false`,
  если `ResultSet` отсутствует, например при запросах вида `INSERT`, `UPDATE`. С помощью методов `getResultSet()`
  мы можем получить `ResultSet`, а `getUpdateCount()` — количество обновленных записей.

+ Метод `executeUpdate()` используется для выполнения операторов `INSERT`, `UPDATE` или `DELETE`, а также для операторов
  DDL (Data Definition Language — язык определения данных), например, `CREATE TABLE` и `DROP TABLE`.
  Результатом оператора `INSERT`, `UPDATE`, или `DELETE` является модификация одной или более колонок в нуле или более
  строках таблицы.

  Метод `executeUpdate()` возвращает целое число, показывающее, сколько строк было модифицировано.
  Для выражений типа `CREATE TABLE` и `DROP TABLE`, которые не оперируют над строками, возвращаемое методом `executeUpdate()`
  значение всегда равно нулю.

Все методы выполнения SQL-запросов закрывают предыдущий набор результатов (`ResultSet`) у данного объекта `Statement`.
Это означает, что перед тем как выполнять следующий запрос над тем же объектом `Statement`,
надо завершить обработку результатов предыдущего (`ResultSet`).

[к оглавлению](#SQL)

## 28. Можно ли использовать возвращаемое значение execute() для проверки, что что-то обновилось?

Можно. Метод возвращает `true`, если результатом является `ResultSet`, как у запроса `SELECT`. Вернет `false`,
если `ResultSet` отсутствует, например при запросах вида `INSERT`, `UPDATE`. С помощью метода `getUpdateCount()` — 
можно вернуть количество обновленных записей.

[к оглавлению](#SQL)

## 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

1. На чистом SQL. В SQL есть ключевое слово RETURNING(поля), которое мы можем использовать в запросе. В итоге запрос 
   вставки будет выглядеть так:
   
```postgres-sql
    INSERT INTO cities(name, population) VALUES ('Ufa', 1000000) RETURNING (id);
```

2. С использованием JDBC. Для того чтобы получить id. Нужно при создании PrepareStatement вторым аргументом передать 
   Statement.RETURNING_GENERATED_KEYS. После как обычно выполнить запрос. Наконец, чтобы получить ключ нужно вызвать 
   метод getGeneratedKeys().
   
```java
public City insert(City city) {
    try (PreparedStatement statement =
                 connection.prepareStatement("insert into cities(name, population) values (?, ?)",
                         Statement.RETURN_GENERATED_KEYS)) {
        statement.setString(1, city.getName());
        statement.setInt(2, city.getPopulation());
        statement.execute();
        try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
            if (generatedKeys.next()) {
                city.setId(generatedKeys.getInt(1));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return city;
}
```

[к оглавлению](#SQL)

## 30. Для чего используется конструкция try-with-resources?


Данная конструкция(`try-with-resources`) появилась в java 7,
она позволяет использовать блок `try-catch` не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после `try`, а компилятор уже сам неявно создаёт секцию `finally` в которой
и происходит закрытие без участия разработчика. Конструкция является так называемым «синтаксическим сахаром»
и создана для облегчения жизни программиста.
Под ресурсами подразумеваются сущности, реализующие интерфейс `java.lang.Autocloseable`.

Общий вид конструкции выглядит следующим образом:

```java
try(тут объявляются ресурсы) {
    ...
    ...
} catch (Exception ex) {
    ...
} finally {
    ...
}
```

внимание, блоки `catch` и явный `finally` выполняются уже после того, как закрываются ресурсы в неявном `finnaly`.

[к оглавлению](#SQL)